<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init

// halves of display   )
enum fg {
  none,
  gesture,
  stick
}

// gesture types
enum gesture {
  none,
  tap,
  longtap,
  swipe
}

ev_gesture_recognized = ev_user0

// width should be always more than height
halfWidth  = display_get_gui_width()  * 0.5
halfHeight = display_get_gui_height() * 0.5     // don't know why
// if started in portrait, swap values
if (display_get_orientation() = display_portrait) or
   (display_get_orientation() = display_portrait_flipped) or
   (halfWidth &lt; halfHeight) {
  halfWidth  = display_get_gui_height() * 0.5
  halfHeight = display_get_gui_width()  * 0.5 
}


stick_x = 0   // float, in percents -100..100
stick_y = 0   // float, in percents -100..100
stick_direction = 0
stick_distance = 0   // in percent 0..100
stick_size = halfHeight*0.4  // radius

gesture_type = gesture.none
gesture_direction = 0        // in degrees
gesture_time = 10        // time before gesture is recognised, in steps
gesture_deadzone = halfHeight*0.25    // radius, in pixels 

gesture_last_type = gesture.none
gesture_last_direction = 0


area_x1[fg.stick] = 0
area_x2[fg.stick] = halfWidth
area_x1[fg.gesture] = halfWidth
area_x2[fg.gesture] = halfWidth * 2


device_mouse_dbclick_enable(false)    // no dbl-click as right click

// two-touch supported
multitouch_maxcount = 2
var i=0
repeat (multitouch_maxcount) {
  fg_press[i] = false
  fg_oX[i] = 0 // origin coords
  fg_oY[i] = 0
  fg_X[i] = 0  // current coords
  fg_Y[i] = 0
  fg_type[i] = fg.none // what half of display is finger in
  i++
}


debugstr = '' 

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>DEBUG</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// debugstr = ''

 debugstr = ''

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i=0
repeat (multitouch_maxcount) {
  var _angle = 360 - point_direction(fg_oX[i], fg_oY[i], fg_X[i], fg_Y[i])
  var _dist =        point_distance (fg_oX[i], fg_oY[i], fg_X[i], fg_Y[i])
  
  if fg_press[i] {
    // swipe
    if gesture_type = gesture.none {
      if _dist &gt; gesture_deadzone {
        gesture_type = gesture.swipe
        gesture_direction = _angle
        event_perform(ev_other, ev_gesture_recognized)
      }  
    }
    // longtap
    if gesture_type = gesture.none {
      if _dist &lt;= gesture_deadzone {
        gesture_type = gesture.longtap
        event_perform(ev_other, ev_gesture_recognized)
      }  
    }
  
  }

  i++
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check landscape mode

// Controls doesn't work when not in landscape mode
/*
if not ( (display_get_orientation() = display_landscape) or
         (display_get_orientation() = display_landscape_flipped) ) 
  exit         
*/

if (display_get_orientation() = display_portrait) or
   (display_get_orientation() = display_portrait_flipped) or
   (halfWidth &lt; halfHeight) 
  exit 
         

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Process input

var i=0
repeat(multitouch_maxcount) {
  var _angle = 360 - point_direction(fg_oX[i], fg_oY[i], fg_X[i], fg_Y[i])
  var _dist =        point_distance (fg_oX[i], fg_oY[i], fg_X[i], fg_Y[i])

  // clear fg if not pressed   !
  if not fg_press[i] {
    if fg_type[i] = fg.stick {
      stick_x = 0
      stick_y = 0
      stick_direction = 0
      stick_distance = 0
    }
    if fg_type[i] = fg.gesture {
      gesture_type = gesture.none
      gesture_direction = 0      
      alarm[0] = -1  
    }
    fg_oX[i] = 0 
    fg_oY[i] = 0
    fg_X[i] = 0  
    fg_Y[i] = 0
    fg_type[i] = fg.none
  }  
  
  // refresh fg pressed status   
  if device_mouse_check_button_pressed(i, mb_left) {
    fg_oX[i] = device_mouse_raw_x(i)
    fg_oY[i] = device_mouse_raw_y(i)
    fg_press[i] = true
    // Определяем тип fg
    if (fg_oX[i] &gt; area_x1[fg.stick]) and (fg_oX[i] &lt; area_x2[fg.stick]) {
      fg_type[i] = fg.stick
      // check if fg.stick already exists
//      show_debug_message('finger pressed at STICK area ('+string(i)+')')
    }
    if (fg_oX[i] &gt; area_x1[fg.gesture]) and (fg_oX[i] &lt; area_x2[fg.gesture]) {
      fg_type[i] = fg.gesture
      // check if fg.gesture already exists
      if fg_type[i] != fg.none
        alarm[0] = gesture_time
//      show_debug_message('finger pressed at GESTURE area ('+string(i)+')')
    }
  }  
  
  if device_mouse_check_button_released(i, mb_left) {
    fg_press[i] = false
    if fg_type[i] = fg.gesture {
      alarm[0] = -1
      // распознавание жестов
      // tap
      if gesture_type = gesture.none {
        if _dist &lt;= gesture_deadzone {
          gesture_type = gesture.tap 
          event_perform(ev_other, ev_gesture_recognized)
        }  
      }
      // longtap
        // recognized in alarm[0]
      // swipe
      if gesture_type = gesture.none {
        if _dist &gt; gesture_deadzone {
          gesture_type = gesture.swipe
          gesture_direction = _angle
          event_perform(ev_other, ev_gesture_recognized)
        }  
      }
    }
    
  }  
  
  // process pressed fg's
  if fg_press[i] {
    fg_X[i] = device_mouse_raw_x(i)
    fg_Y[i] = device_mouse_raw_y(i)
    // set stick values
    if fg_type[i] = fg.stick {
      stick_x = (fg_X[i] - fg_oX[i]) / stick_size * 100 // %
      stick_y = (fg_Y[i] - fg_oY[i]) / stick_size * 100 // %
      if abs(stick_x) &gt; 100 stick_x = 100*sign(stick_x)  // %
      if abs(stick_y) &gt; 100 stick_y = 100*sign(stick_y)  // %
      stick_distance  = _dist / stick_size * 100
      if stick_distance &gt; 100 stick_distance = 100
      stick_direction = _angle
    }
  }
  
  i++                   
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>GESTURE RECOGNIZED</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Action
gesture_last_type = gesture_type
gesture_last_direction = gesture_direction


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Debug

switch gesture_last_type {
case gesture.none:
  debugstr = 'none'
  break
case gesture.tap:
  debugstr = 'tap'
  break
case gesture.longtap:
  debugstr = 'longtap'
  break
case gesture.swipe:
  debugstr = 'swipe'
  break
}

// timeout before debugstr = ''
alarm[1] = 5 

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check landscape mode

// Controls doesn't work when not in landscape mode

if (display_get_orientation() = display_portrait) or
   (display_get_orientation() = display_portrait_flipped) or
   (halfWidth &lt; halfHeight) 
  exit 
         

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw info

draw_set_colour(c_white)

var i = 0
var d = stick_distance * 0.01 * stick_size

repeat (multitouch_maxcount) {
  if fg_press[i] {
    if fg_type[i] = fg.stick {
      draw_set_alpha(0.05)
      draw_circle(fg_oX[i], fg_oY[i], stick_size, false)
      draw_set_alpha(0.1)
      draw_circle(fg_oX[i]+cos(degtorad(stick_direction))*d, fg_oY[i]+sin(degtorad(stick_direction))*d, stick_size*0.5, false)

    }
    if fg_type[i] = fg.gesture {
      draw_set_alpha(0.05)
      draw_circle(fg_oX[i], fg_oY[i], gesture_deadzone, false)
      draw_set_alpha(0.1)
      draw_line_width(fg_oX[i], fg_oY[i], fg_X[i], fg_Y[i], gesture_deadzone)
      
    }
  }
  
  i++
}

draw_set_alpha(1)

var _sc = 0.8
// draw stick stats
draw_text_transformed(area_x1[fg.stick]+10, 15, 'x =   '+string(stick_x), _sc, _sc, 0)
draw_text_transformed(area_x1[fg.stick]+10, 25, 'y =   '+string(stick_y), _sc, _sc, 0)
draw_text_transformed(area_x1[fg.stick]+10, 35, 'distance =   ' +string(stick_distance),  _sc, _sc, 0)
draw_text_transformed(area_x1[fg.stick]+10, 45, 'direction =   '+string(stick_direction), _sc, _sc, 0)

// draw gesture_last (debugstr)
var _s = ''
switch gesture_type {
case gesture.none:
  _s = 'none';    break
case gesture.tap:
  _s = 'tap';     break
case gesture.longtap:
  _s = 'longtap'; break
case gesture.swipe:
  _s = 'swipe';   break
}

draw_text_transformed(area_x1[fg.gesture]+10, 15, 'type =   '+_s, _sc, _sc, 0)
draw_text_transformed(area_x1[fg.gesture]+10, 25, 'last_type =   '+debugstr, _sc, _sc, 0)


draw_text_transformed(halfWidth, halfHeight * 2 - 30, 'width  = '+string(halfWidth * 2), _sc, _sc, 0)
draw_text_transformed(halfWidth, halfHeight * 2 - 20, 'height = '+string(halfHeight * 2), _sc, _sc, 0)

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
